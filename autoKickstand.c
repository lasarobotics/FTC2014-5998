#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S4,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     rightWheel1,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     leftWheel1,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     leftWheel2,    tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S3_C1_1,    front,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    back,                 tServoStandard)
#pragma config(Servo,  srvo_S3_C1_3,    lift1,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_4,    lift2,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************************************************************\
| Functions:
|
| resetEncoders()
|     Resets the read encoder values.
|     This makes sure we don't mess up after turning or at the start of a match
| stopMotors()
|		 Makes it easier to monitor functions. Called Often
| forward(rotations, power)
|		 goes forward for a number of rotations.
|		 automatically aligns after left wheel has travelled far enough
| turnLeft(rotations, power)
|		 turns left for the specified number of rotations.
| turnRight(rotations, power)
|		 turns right for the specified number of rotations.
\**********************************************************************************************/
#define backDown 225
#define backUp 125
#define frontDown 225
#define frontUp 125
#define liftOneUp 250
#define liftTwoUp 0
#define liftOneDown 0
#define liftTwoDown 250
void showStatus(int rotations, int power){
		nxtDisplayTextLine(1, "Power: %d", power);
		nxtDisplayTextLine(2, "rotations: %d",rotations);
		nxtDisplayTextLine(3, "encoders: %d",nMotorEncoder[leftWheel1]);
		nxtDisplayTextLine(4, "encoders: %d",nMotorEncoder[leftWheel2]);
		nxtDisplayTextLine(5, "encoders: %d",nMotorEncoder[rightWheel1]);
		nxtDisplayTextLine(6, "encoders: %d",nMotorEncoder[rightWheel2]);
}
void armUp(){
	servo[lift1] = liftOneUp;
	servo[lift2] = liftTwoUp;
}
void armDown(){
	servo[lift1] = liftOneDown;
	servo[lift2] = liftTwoDown;
}
void frontServoUp(){
	servo[front] = frontUp;
}
void frontServoDown(){
	servo[front] = frontDown;
}
void backServoUp(){
	servo[back] = backUp;
}
void backServoDown(){
	servo[back] = backDown;
}
void resetEncoders(){
	nMotorEncoder[leftWheel1] = 0;
	nMotorEncoder[leftWheel2] = 0;
	nMotorEncoder[rightWheel1] = 0;
	nMotorEncoder[rightWheel2] = 0;
}//resets motor encoders
void stopMotors(){
	wait1Msec(100);
	motor[rightWheel1] = 0;
	motor[rightWheel2] = 0;
	motor[leftWheel1] = 0;
	motor[leftWheel2] = 0;
	resetEncoders();
}//stops drive

void forward( int rotations, int power ){
	resetEncoders(); //Resets the motor encoder readings.
	while( (nMotorEncoder[leftWheel1] < rotations) && (nMotorEncoder[rightWheel1] < rotations) && (nMotorEncoder[leftWheel2]) < rotations && (nMotorEncoder[rightWheel2] < rotations)){
		showStatus(rotations, power);
		motor[leftWheel1] = power;
		motor[rightWheel1] = power;
		motor[leftWheel2] = power;
		motor[rightWheel2] = power;
	}//goes forward until one of the two sides has rotated enough
	stopMotors();

	if( ( nMotorEncoder[leftWheel1] + nMotorEncoder[leftWheel2] ) - ( nMotorEncoder[rightWheel1] + nMotorEncoder[rightWheel2] ) > 100){
		//if shifted to face left
		while( nMotorEncoder[leftWheel1] - nMotorEncoder[rightWheel1] > 0 ){
			motor[rightWheel1] = power / 5;//turns to be straight
		}
			stopMotors();
			resetEncoders();
			return;
	}
	if( ( nMotorEncoder[rightWheel1] + nMotorEncoder[rightWheel2] ) - ( nMotorEncoder[leftWheel1] + nMotorEncoder[leftWheel2] ) > 100 ){
		//if shifted to face right
		while( nMotorEncoder[rightWheel1] - nMotorEncoder[leftWheel1] > 0 ){
			motor[leftWheel1] = power/5;//turns to be straight
		}
	}

	stopMotors();
	resetEncoders();
}//forward function


void backwards(int rotations, int power){
	resetEncoders(); //Resets the motor encoder readings.
	while( (abs(nMotorEncoder[leftWheel1]) < rotations) || (abs(nMotorEncoder[rightWheel1]) < rotations) || (abs(nMotorEncoder[leftWheel2]) < rotations) || (abs(nMotorEncoder[rightWheel2]) < rotations)){
		showStatus(rotations, power);
		motor[leftWheel1] = -power;
		motor[rightWheel1] = -power;
		motor[leftWheel2] = -power;
		motor[rightWheel2] = -power;
	}//goes forward until one of the two sides has rotated enough
	stopMotors();

	if( abs(( nMotorEncoder[leftWheel1] + nMotorEncoder[leftWheel2] ) - ( nMotorEncoder[rightWheel1] + nMotorEncoder[rightWheel2] )) > 100){
		//if shifted to face left
		while( nMotorEncoder[leftWheel1] - nMotorEncoder[rightWheel1] > 0 ){
			motor[rightWheel1] = -power / 5;//turns to be straight
		}
			stopMotors();
			resetEncoders();

	}
	if( abs(( nMotorEncoder[rightWheel1] + nMotorEncoder[rightWheel2] ) - ( nMotorEncoder[leftWheel1] + nMotorEncoder[leftWheel2] )) > 100 ){
		//if shifted to face right
		while( nMotorEncoder[rightWheel1] - nMotorEncoder[leftWheel1] > 0 ){
			motor[leftWheel1] = -power/5;//turns to be straight
		}
	}

	stopMotors();
	resetEncoders();
}

void turnLeft(int rotations, int power){
	resetEncoders();//resets encoders
	while( (nMotorEncoder[rightWheel2] < rotations) && abs(nMotorEncoder[leftWheel2]) < rotations ){
		showStatus(rotations, power);
		motor[rightWheel2] = power;
		motor[rightWheel1] = power;
		motor[leftWheel2] = 0;
		motor[leftWheel1] = 0;
 	}
 	stopMotors();
 	return;
}//turns left

void turnRight(int rotations, int power){
	resetEncoders();//resets encoders
	while( (nMotorEncoder[leftWheel2] < rotations) && abs(nMotorEncoder[rightWheel2]) < rotations ){
		showStatus(rotations, power);
		motor[rightWheel2] = 0;
		motor[rightWheel1] = 0;
		motor[leftWheel2] = power;
		motor[leftWheel1] = power;
 	}
 	stopMotors();
 	return;
 }//turns right
void initializeRobot()
{
 	armUp();
 	frontServoUp();
	backServoUp();
	return;
}

//Start of Auto















task main()
{
	int startWait = 1;
	bool kickstand = true;
	int kickTime = 15;
	bool check = false;
	int spot = 4;
	while(check == false) {
		eraseDisplay();
		nxtDisplayCenteredTextLine(1, "-----LASA5998----");
		nxtDisplayCenteredTextLine(2, "-Pick Autonomous-");
		nxtDisplayCenteredTextLine(3, "--------------------");
		if(spot == 4){
			nxtDisplayTextLine(4, "> StartWait: %d  <", startWait);
		} else {
			nxtDisplayTextLine(4, "  StartWait: %d   ", startWait);
		}
		if(spot == 5){
			nxtDisplayTextLine(5, "> Kickstand: %d  <", kickstand);
		} else {
			nxtDisplayTextLine(5, "  Kickstand: %d   ", kickstand);
		}
		if(spot == 4){
			nxtDisplayTextLine(6, "> KickTime:  %d<", kickTime);
		} else {
			nxtDisplayTextLine(6, "  Kick Time:  %d  ", kickTime);
		}
		nxtDisplayTextLine(7, "_________________");
		nxtDisplayTextLine(8, "_________________");
		if (nNxtButtonPressed ==  kRightButton) { /* Right Button  */
			if (spot == 4 && startWait < 10) {
				startWait++;
			}
			if (spot == 5){
				kickstand = !kickstand;
			}
			if(spot == 6 && kickTime < 28){
				kickTime++;
			}
		}
		if( nNxtButtonPressed == kLeftButton) { /* Left Button  */
			if(spot == 4 && startWait > 1){
				startWait--;
			}
			if(spot == 5){
				kickstand = !kickstand;
			}
			if(spot == 6 && kickTime > 15){
				kickTime--;
			}
		}
		if( (nNxtButtonPressed == kEnterButton) && spot != 6 ) { // Middle Button
			spot++;
		}
		if( (nNxtButtonPressed == kEnterButton) && spot == 6) { // Middle Button
			check = true;
		}
		wait1Msec(2000);
	}
	while(check == true){
		nxtDisplayTextLine(1, "-----LASA5998----");
		nxtDisplayTextLine(2, "-Pick Autonomous-");
		nxtDisplayTextLine(3, "_________________");
		nxtDisplayTextLine(4, "> StartWait: %d  <", startWait);
		nxtDisplayTextLine(5, "> Kickstand: %d  <", kickstand);
		nxtDisplayTextLine(6, "> Kick Time:  %d <", kickTime);
		nxtDisplayCenteredTextLine(7, " -- Press Orange --");
		nxtDisplayCenteredTextLine(8, " -- to Confirm -- ");
		while(nNxtButtonPressed == false){ /*Center Button*/
			wait1Msec(20);
		}
	}

	//waitForStart(); //waits for Starts
	ClearTimer(T1);
	int zone;
  wait1Msec(500);
	nxtDisplayCenteredTextLine(3, "IR Value: %d", SensorValue[ir]);
 	wait10Msec(50);
 	if(SensorValue[ir] == 3){
 		zone = 1;
	}
	else if(SensorValue[ir] == 4){
		zone = 2;
	}
	else if(SensorValue[ir] == 5){
		zone = 3;
	}
	else{
		zone = 0;
	}
	initializeRobot();

	if( zone == 3){
		forward(500, 20);
		turnRight(350, 20);
		forward(1750, 20);
		turnLeft(350, 20);
		forward(800, 20);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}
	if( zone == 2){
		forward(250, 20);
		turnLeft(800, 20);
		forward(1400, 20);
		turnRight(1650, 20);
		forward(1700, 20);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}
	if( zone == 1 ){
	forward(250, 20);
		turnLeft(1200, 20);
		forward(800, 20);
		turnRight(1400, 20);
		forward(2700, 20);
		turnRight(1450, 20);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}

	if (kickstand){
		backwards(500, 20);
		turnLeft(350, 20);
		forward(1750, 20);
		turnRight(350, 20);

		while( time1[T1] < kickTime ){
			wait1Msec(1);
		}

		forward(800, 20);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}
}
