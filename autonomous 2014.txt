#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    rightClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    leftClaw,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)

#define power 100
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int waitTime = 0;

void setWaitTime()
//this code allows the user to set how long the robot waits to start to drive.
// because of this, we can make sure that we don't run into our partner robot
{
	while ( nNxtButtonPressed == 3 ){
		nxtDisplayCenteredBigTextLine(2, "The robot will wait for:" );
		nxtDisplayCenteredBigTextLine(3, waitTime*500);
		nxtDisplayCenteredBigTextLine(4, "Milliseconds");
		if((nNxtButtonPressed == 1) && (waitTime < 51))
		{
			waitTime++;
		}
		if( (nNxtButtonPressed == 2) && (waitTime > 0) )
		{
			waitTime--;
		}
	}
}

void stopMotors()
{
motor[rightWheel]=0;
motor[leftWheel]=0;
}
void drivemotors(int n1,int time)
{
motor[rightWheel]=	n1;
motor[leftWheel]= n1;
wait1Msec(time);
stopMotors();
}
void turnMotors(int right, int left)
{
motor[rightWheel]= right;
motor[leftWheel]= left;
wait1Msec(time);
stopMotors();
}

task main()
{



}
