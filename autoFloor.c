#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S3, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     rightWheel1,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     leftWheel1,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     leftWheel2,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S3_C2_1,     Infeed,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C2_2,     Pulley,        tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    drop,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    back,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************************************************************\
| Functions:
|
| resetEncoders()
|     Resets the read encoder values.
|     This makes sure we don't mess up after turning or at the start of a match
| stopMotors()
|		 Makes it easier to monitor functions. Called Often
| forward(rotations, power)
|		 goes forward for a number of rotations.
|		 automatically aligns after left wheel has travelled far enough
| turnLeft(rotations, power)
|		 turns left for the specified number of rotations.
| turnRight(rotations, power)
|		 turns right for the specified number of rotations.
\**********************************************************************************************/
#define backDown 225
#define backUp 125
#define frontDown 225
#define frontUp 125
#define liftOneUp 250
#define liftTwoUp 0
#define liftOneDown 0
#define liftTwoDown 250
void showStatus(int rotations, int power){
		nxtDisplayTextLine(1, "Power: %d", power);
		nxtDisplayTextLine(2, "rotations: %d",rotations);
		nxtDisplayTextLine(3, "encoders: %d",nMotorEncoder[leftWheel1]);
		nxtDisplayTextLine(4, "encoders: %d",nMotorEncoder[leftWheel2]);
		nxtDisplayTextLine(5, "encoders: %d",nMotorEncoder[rightWheel2]);
}
void backServoUp(){//this moves the down servo to the upright position
	servo[back] = backUp;
}
void backServoDown(){//this moves the back servo to the down position
	servo[back] = backDown;
}
void resetEncoders(){//clears all encoders
	nMotorEncoder[leftWheel1] = 0;
	nMotorEncoder[leftWheel2] = 0;
	nMotorEncoder[rightWheel2] = 0;
	nMotorEncoder[Pulley] = 0;
}//resets motor encoders
void stopMotors(){//this wait for it... stops the motors
	wait1Msec(100);
	motor[rightWheel1] = 0;
	motor[rightWheel2] = 0;
	motor[leftWheel1] = 0;
	motor[leftWheel2] = 0;
	resetEncoders();
}//stops drive

void forward( int rotations, int power ){//this drives forward the desired rotations at the desired power
	resetEncoders(); //Resets the motor encoder readings.
	while( (nMotorEncoder[leftWheel1] < rotations) && (nMotorEncoder[rightWheel2] < rotations) && (nMotorEncoder[leftWheel2]) < rotations){
		showStatus(rotations, power);
		motor[leftWheel1] = power;
		motor[rightWheel1] = power;
		motor[leftWheel2] = power;
		motor[rightWheel2] = power;
	}//goes forward until one of the motors has rotated enough
	stopMotors();
	resetEncoders();
}//forward function


void backwards(int rotations, int power){
	resetEncoders(); //Resets the motor encoder readings.
	while( (abs(nMotorEncoder[leftWheel1]) < rotations) || (abs(nMotorEncoder[rightWheel2]) < rotations) || (abs(nMotorEncoder[leftWheel2]) < rotations)){
		showStatus(rotations, power);
		motor[leftWheel1] = -power;
		motor[rightWheel1] = -power;
		motor[leftWheel2] = -power;
		motor[rightWheel2] = -power;
	}//goes back until one of the motors has rotated enough
	stopMotors();
	resetEncoders();
}
void turnLeft(int rotations, int power){
	resetEncoders();//resets encoders
	while( (nMotorEncoder[rightWheel2] < rotations) && abs(nMotorEncoder[leftWheel2]) < rotations ){
		showStatus(rotations, power);
		motor[rightWheel2] = power;
		motor[rightWheel1] = power;
		motor[leftWheel2] = 0;
		motor[leftWheel1] = 0;
 	}
 	stopMotors();
 	return;
}//turns left

void turnRight(int rotations, int power){
	resetEncoders();//resets encoders
	while( (nMotorEncoder[leftWheel2] < rotations) && abs(nMotorEncoder[rightWheel2]) < rotations ){
		showStatus(rotations, power);
		motor[rightWheel2] = 0;
		motor[rightWheel1] = 0;
		motor[leftWheel2] = power;
		motor[leftWheel1] = power;
 	}
 	stopMotors();
 	return;
 }//turns right
void initializeRobot()
{
	backServoUp();
	servo[drop] = 140;
	return;
}
void intakeDown(){
	motor[Infeed] = 100;
	forward(200, 20);
	motor[Infeed] = 0;
}

//Start of Auto















task main()
{
	int startWait = 1;
	int selection = 4;
	int kickTime = 15;
	bool kickstand = true;
	bool cont = false;


	bDisplayDiagnostics = false;
	while(selection != 7){
		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "+--------------+");
		nxtDisplayCenteredTextLine(1, "|  LASA 5998   |");
		nxtDisplayCenteredTextLine(2, "|PickAutonomous|");
		nxtDisplayCenteredTextLine(3, "+--------------+");
		if(selection == 4){
			nxtDisplayCenteredTextLine(4, "->StartWait: %d  ", startWait);
		} else {
			nxtDisplayCenteredTextLine(4, "StartWait: %d  ", startWait);
		}
		if(selection == 5){
			if(kickstand == true){
				nxtDisplayCenteredTextLine(5, "->Kickstand: Yes");
			}else{
				nxtDisplayCenteredTextLine(5, "->Kickstand: No");
			}
		} else {
			if(kickstand == true){
				nxtDisplayCenteredTextLine(5, "Kickstand: Yes");
			}else{
				nxtDisplayCenteredTextLine(5, "Kickstand: No");
			}
		}
		if(selection == 6){
			nxtDisplayCenteredTextLine(6, "->KickTime:%d ", kickTime);
		} else {
			nxtDisplayCenteredTextLine(6, "Kick Time:%d ", kickTime);
		}
		nxtDisplayCenteredTextLine(7, "-----------------------", selection);

		cont = false;
		while(cont == false){
			wait1Msec(200);
			if (nNxtButtonPressed == 2){
				if( (selection == 4) && (startWait > 1) ){
					startWait--;
					cont = true;
				}
				if(selection == 5){
					kickstand = !kickstand;
					cont = true;
				}
				if( (selection == 6) && (kickTime > 15)){
					kickTime--;
					cont = true;
				}
			}
			if(nNxtButtonPressed == 1){
				if( (selection == 4) && (startWait < 10) ){
					cont = true;
					startWait++;
				}
				if(selection == 5){
					kickstand = !kickstand;
					cont = true;
				}
				if( (selection == 6) && (kickTime < 27)){
					kickTime++;
					cont = true;
				}
			}
			if(nNxtButtonPressed == 3){
				selection++;
				cont = true;
			}
		}
	}
	eraseDisplay();
	nxtDisplayBigTextLine(3, "Press Enter");
	while(nNxtButtonPressed != 3){
		wait1Msec(1);
	}
	eraseDisplay();
	nxtDisplayBigTextLine(3, "Ready");
	//waitForStart(); //waits for Start Command From FCS
	ClearTimer(T1);
	eraseDisplay();
	nxtDisplayBigTextLine(3, "Go!");
	intakeDown();
	wait1Msec(1000*startWait);
	while(nMotorEncoder[Pulley] < 39550){
		motor[Pulley] = 100;
	}
	motor[Pulley] = 0;
	int zone;

	wait1Msec(500);
	nxtDisplayCenteredTextLine(3, "IR Value: %d", SensorValue[ir]);
 	wait10Msec(50);
 	if(SensorValue[ir] == 3 || SensorValue[ir] == 0){
 		zone = 1;
	}
	else if(SensorValue[ir] == 4){
		zone = 2;
	}
	else if(SensorValue[ir] == 5){
		zone = 3;
	}
	else{
		zone = 0;
	}
	initializeRobot();

	if( (zone == 3) || (zone == 0) ){
		turnRight(350, 35);
		forward(3000, 35);
		turnLeft(350, 35);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}
	if( zone == 2){
		forward(250, 35);
		turnLeft(800, 35);
		forward(1100, 35);
		turnRight(1500, 35);
		forward(1200, 20);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}
	if( zone == 1 ){
		forward(250, 35);
		turnLeft(1200, 35);
		forward(900, 35);
		turnRight(1100, 35);
		forward(2400, 35);
		turnRight(1550, 35);
		PlaySound(soundBeepBeep);
		wait1Msec(1000);
	}

	servo[drop] = 65;
	PlaySound(soundBeepBeep);
	wait1Msec(50);
}
