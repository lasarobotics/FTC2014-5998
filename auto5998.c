#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     rightWheel1,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     leftWheel1,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     leftWheel2,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_1,     h,             tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     kjg,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S3_C1_1,    front,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    back,                 tServoStandard)
#pragma config(Servo,  srvo_S3_C1_3,    lift1,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_4,    lift2,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************************************************************\
| Functions:
|
| resetEncoders()
|     Resets the read encoder values.
|     This makes sure we don't mess up after turning or at the start of a match
| stopMotors()
|		 Makes it easier to monitor functions. Called Often
| forward(rotations, power)
|		 goes forward for a number of rotations.
|		 automatically aligns after left wheel has travelled far enough
| turnLeft(rotations, power)
|		 turns left for the specified number of rotations.
| turnRight(rotations, power)
|		 turns right for the specified number of rotations.
\**********************************************************************************************/
//Need to fix variables. Free trial doesn't allow tool use.
#define backDown 225
#define backUp 125
#define frontDown 225
#define frontUp 125
#define liftOneUp 250
#define liftTwoUp 0
#define liftOneDown 0
#define liftTwoDown 250
void armUp(){
	servo[lift1] = liftOneUp;
	servo[lift2] = liftTwoUp;
}
void armDown(){
	servo[lift1] = liftOneDown;
	servo[lift2] = liftTwoDown;
}
void servoFrontUp(){
	servo[front] = frontUp;
}
void servoFrontDown(){
	servo[front] = frontDown;
}
void servoBackUp(){
	servo[back] = backUp;
}
void servoBackDown(){
	servo[back] = backDown;
}
void resetEncoders(){
	nMotorEncoder[leftWheel1] = 0;
	nMotorEncoder[leftWheel2] = 0;
	nMotorEncoder[rightWheel1] = 0;
	nMotorEncoder[rightWheel2] = 0;
}//resets motor encoders
void stopMotors(){
	wait1Msec(100);
	motor[rightWheel1] = 0;
	motor[rightWheel2] = 0;
	motor[leftWheel1] = 0;
	motor[leftWheel2] = 0;
	resetEncoders();
}//stops drive

void forward( int rotations, int power ){
	resetEncoders(); //Resets the motor encoder readings.
	while( (nMotorEncoder[leftWheel1] < rotations) && (nMotorEncoder[rightWheel1] < rotations) && (nMotorEncoder[leftWheel2]) < rotations && (nMotorEncoder[rightWheel2] < rotations)){
		motor[leftWheel1] = power;
		motor[rightWheel1] = power;
		motor[leftWheel2] = power;
		motor[rightWheel2] = power;
	}//goes forward until one of the two sides has rotated enough
	stopMotors();

	if( ( nMotorEncoder[leftWheel1] + nMotorEncoder[leftWheel2] ) - ( nMotorEncoder[rightWheel1] + nMotorEncoder[rightWheel2] ) > 100){
		//if shifted to face left
		while( nMotorEncoder[leftWheel1] - nMotorEncoder[rightWheel1] > 0 ){
			motor[rightWheel1] = power / 5;//turns to be straight
		}
			stopMotors();
			resetEncoders();
			return;
	}
	if( ( nMotorEncoder[rightWheel1] + nMotorEncoder[rightWheel2] ) - ( nMotorEncoder[leftWheel1] + nMotorEncoder[leftWheel2] ) > 100 ){
		//if shifted to face right
		while( nMotorEncoder[rightWheel1] - nMotorEncoder[leftWheel1] > 0 ){
			motor[leftWheel1] = power/5;//turns to be straight
		}
	}

	stopMotors();
	resetEncoders();
}//forward function



















void backwards(int rotations, int power){
	nMotorEncoder[leftWheel1] = rotations;
	nMotorEncoder[rightWheel1] = rotations;
	nMotorEncoder[leftWheel2] = rotations;
	nMotorEncoder[rightWheel2] = rotations;
	while( (nMotorEncoder[leftWheel1] > 0) && (nMotorEncoder[rightWheel1] > 0) && (nMotorEncoder[leftWheel2] > 0) && (nMotorEncoder[rightWheel2] > 0)){
			motor[leftWheel1] = -power;
			motor[rightWheel1] = -power;
			motor[leftWheel2] = -power;
			motor[rightWheel2] = -power;
	}//goes backward until one of the two sides has rotated enough
}

void turnLeft(int rotations, int power){
	resetEncoders();//resets encoders
	while(nMotorEncoder[rightWheel2] < rotations){
		motor[rightWheel2] = power;
		motor[leftWheel2] = -power;
 	}
 	stopMotors();
 	return;
}//turns left

void turnRight(int rotations, int power){
	resetEncoders();//resets encoders
	while(nMotorEncoder[leftWheel2] < rotations){
		motor[leftWheel2] = power;
		motor[rightWheel2] = -power;
 	}
 	stopMotors();
 	return;
}//turns right
//Start of Auto
task main()
{
	armUp();
	servoFrontUp();
	// DEBUG servoBackUp();
	//Servos
	armUp();
	forward(7500, 100);
	stopMotors();
	//Drives Down The Ramp

	armUp();
	servoFrontDown();
	turnLeft(3750, 60);
	wait1Msec(500);
	//turns to face the other tube

	armUp();
	servoBackUp();
	wait1Msec(500);
	backwards(4000, 80); //backwards is line 120
	servoBackDown();
	//backs into the second tube and grabs it



		wait1Msec(500);
}
